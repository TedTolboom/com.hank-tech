'use strict';

const ZwaveDevice = require('./ZwaveDevice');
const util = require('../util');
const FACTORY_DEFAULT_DIMMING_DURATION = 'Factory default';
const FACTORY_DEFAULT_COLOR_DURATION = 255;

/**
 * The ZwaveXYLightDevice takes care of all commands normally used by XY Lighting devices
 * @extends ZwaveDevice
 * @example
 *
 * // device.js
 * const ZwaveXYLightDevice = require('homey-meshdriver').ZwaveXYLightDevice;
 *
 * class myDevice extends ZwaveXYLightDevice {
 *
 * 	async onMeshInit() {
 *
 * 		await super.onMeshInit();
 * 		// YOUR CODE COMES HERE
 * 		}
 * 	}
 */

class ZwaveXYLightDevice extends ZwaveDevice {

	onMeshInit() {

		// Check if all used capabilities are present
		if (!this.hasCapability('light_hue')) return this.error('missing_capability_light_hue');
		if (!this.hasCapability('light_saturation')) return this.error('missing_capability_light_saturation');
		if (!this.hasCapability('light_temperature')) return this.error('missing_capability_light_temperature');
		if (!this.hasCapability('light_mode')) return this.error('missing_capability_light_mode');
		if (!this.hasCapability('dim')) return this.error('missing_capability_dim');
		if (!this.hasCapability('onoff')) return this.error('missing_capability_onoff');

		// Register capabilities
		if (this.hasCommandClass('SWITCH_MULTILEVEL')) {

			this.registerCapability('onoff', 'SWITCH_MULTILEVEL');
			this.registerCapability('dim', 'SWITCH_MULTILEVEL');

		// If multilevel switch is not available fall back to basic
		} else if(this.hasCommandClass('BASIC')) {

			this.registerCapability('onoff', 'BASIC');
			this.registerCapability('dim', 'BASIC');

		} else return this.error('could not register onoff and dim capabilities');

		this.registerMultipleCapabilityListener(['light_hue', 'light_saturation', 'light_mode'], this._onColor.bind(this), 500);
		this.registerMultipleCapabilityListener(['light_temperature', 'light_mode'], this._onTemperature.bind(this), 500);

		let CC_ColorSwitch = this.getCommandClass('SWITCH_COLOR');

		// Getting all color values
		if (!(CC_ColorSwitch instanceof Error) && typeof CC_ColorSwitch.SWITCH_COLOR_GET === 'function') {
			setTimeout(() => {
				// Get Warm White
				const WarmWhite = new Promise((resolve, reject) => {
					CC_ColorSwitch.SWITCH_COLOR_GET({
						'Color Component ID': 0,
					})
						.catch(error => {
							this.error(error);
							return resolve(0);
						})
						.then(result => resolve((typeof result.Value === 'number') ? result.Value : 0));
				});

				// Get Cold White
				const ColdWhite = new Promise((resolve, reject) => {
					CC_ColorSwitch.SWITCH_COLOR_GET({
						'Color Component ID': 1
					})
						.catch(error => {
							this.error(error);
							return resolve(0);
						})
						.then(result => resolve((typeof result.Value === 'number') ? result.Value : 0));
				});

				// Get Red
				const Red = new Promise((resolve, reject) => {
					CC_ColorSwitch.SWITCH_COLOR_GET({
						'Color Component ID': 2
					})
						.catch(error => {
							this.error(error);
							return resolve(0);
						})
						.then(result => resolve((typeof result.Value === 'number') ? result.Value : 0));
				});

				// Get Green
				const Green = new Promise((resolve, reject) => {
					CC_ColorSwitch.SWITCH_COLOR_GET({
						'Color Component ID': 3
					})
						.catch(error => {
							this.error(error);
							return resolve(0);
						})
						.then(result => resolve((typeof result.Value === 'number') ? result.Value : 0));
				});

				// Get Blue
				const Blue = new Promise((resolve, reject) => {
					CC_ColorSwitch.SWITCH_COLOR_GET({
						'Color Component ID': 4
					})
						.catch(error => {
							this.error(error);
							return resolve(0);
						})
						.then(result => resolve((typeof result.Value === 'number') ? result.Value : 0));
				});

				// Wait for all values to arrive and set capabilities
				Promise.all([WarmWhite, ColdWhite, Red, Green, Blue])
					.then(result => {
						// Determine light_mode
						if (result[0] === 0 && result[1] === 0) this.setCapabilityValue('light_mode', 'color');
						else this.setCapabilityValue('light_mode', 'temperature');

						// Convert RGB to HSV values
						const hsv = util.convertRGBToHSV({
							red: result[2],
							green: result[3],
							blue: result[4]
						});

						// Update capability values
						this.setCapabilityValue('light_hue', hsv['hue']);
						this.setCapabilityValue('light_saturation', hsv['saturation']);
						if (result[0] !== 0) this.setCapabilityValue('light_temperature', map(0, 255, 0, 1, result[0]));
						else this.setCapabilityValue('light_temperature', map(255, 0, 0, 1, result[1]));
					});
			}, 500);
		}
	}

	// If a color change was initiated
	_onColor(valueObj, optsObj) {
		// Check if the value has a light_mode change if so change it accordingly
		if (valueObj.hasOwnProperty('light_mode')) {
			this.setCapabilityValue('light_mode', valueObj.light_mode);
			if (valueObj.light_mode !== 'temperature') return;
		}

		// If the light_mode is not color, abort
		if (this.getCapabilityValue('light_mode') !== 'color') return;

		// Convert HSV to RGB values
		let hue = valueObj.light_hue;
		if (typeof hue !== 'number') hue = this.getCapabilityValue('light_hue', ) || 1;

		let saturation = valueObj.light_saturation;
		if (typeof saturation !== 'number') saturation = this.getCapabilityValue('light_saturation') || 1;

		const rgb = util.convertHSVToRGB({
				hue: hue,
				saturation: saturation,
				value: 1,
		});

		let CC_ColorSwitch = this.getCommandClass('SWITCH_COLOR');

		if (!(CC_ColorSwitch instanceof Error) && typeof CC_ColorSwitch.SWITCH_COLOR_SET === 'function') {

			// Get and calculate duration
			const hueDuration = (optsObj && optsObj.hasOwnProperty('light_hue') && optsObj.light_hue.hasOwnProperty('duration')) ? util.calculateZwaveDimDuration(optsObj.light_hue.duration) : undefined;
			const saturationDuration = (optsObj && optsObj.hasOwnProperty('light_saturation') && optsObj.light_saturation.hasOwnProperty('duration')) ? util.calculateZwaveDimDuration(optsObj.light_saturation.duration) : undefined;
			const duration = hueDuration || saturationDuration || FACTORY_DEFAULT_COLOR_DURATION;

			// Construct the set command
			let setCommand = {
				Properties1: {
					'Color Component Count': 5,
				},
				vg1: [
					{
						'Color Component ID': 0, // Warm White
						Value: 0,
					},
					{
						'Color Component ID': 1, // Cold White
						Value: 0,
					},
					{
						'Color Component ID': 2, // Red
						Value: rgb['red'],
					},
					{
						'Color Component ID': 3, // Green
						Value: rgb['green'],
					},
					{
						'Color Component ID': 4, // Blue
						Value: rgb['blue'],
					},
				],
			}

			// Add duration to Switch Color version 2 and up
			if (CC_ColorSwitch.version > 1) setCommand.duration = duration;

			// Send the set command to the device
			CC_ColorSwitch.SWITCH_COLOR_SET(setCommand)
				.catch(error => {
					return Promise.resolve(error, false);
				})
				.then(result => {
					if (result !== 'TRANSMIT_COMPLETE_OK') return Promise.resolve(result, false);

					this.setCapabilityValue('light_hue', hue);
					this.setCapabilityValue('light_saturation', saturation);

					return Promise.resolve(true);
				});
		}

		else return Promise.resolver('something_went_wrong', false);
	}

	// If a light temperature change was initiated
	_onTemperature(valueObj, optsObj) {
		// Check if the value has a light_mode change if so change it accordingly
		if (valueObj.hasOwnProperty('light_mode')) {

			this.setCapabilityValue('light_mode', valueObj.light_mode);
			if (valueObj.light_mode !== 'temperature') return;
		}

		// If light mode is not temperature, abort
		if (this.getCapabilityValue('light_mode') !== 'temperature') return;

		// Convert temperature to warm and cold white values
		let temperature = valueObj.light_temperature;
		if (typeof temperature !== 'number') temperature = this.getCapabilityValue('light_temperature');

		const WarmWhite = Math.round(map(0, 1, 0, 255, temperature));
		const ColdWhite = Math.round(map(0, 1, 255, 0, temperature));

		let CC_ColorSwitch = this.getCommandClass('SWITCH_COLOR');

		if (!(CC_ColorSwitch instanceof Error) && typeof CC_ColorSwitch.SWITCH_COLOR_SET === 'function') {

			// Get and calculate duration
			const hueDuration = (optsObj && optsObj.hasOwnProperty('light_hue') && optsObj.light_hue.hasOwnProperty('duration')) ? util.calculateZwaveDimDuration(optsObj.light_hue.duration) : undefined;
			const saturationDuration = (optsObj && optsObj.hasOwnProperty('light_saturation') && optsObj.light_saturation.hasOwnProperty('duration')) ? util.calculateZwaveDimDuration(optsObj.light_saturation.duration) : undefined;
			const duration = hueDuration || saturationDuration || FACTORY_DEFAULT_COLOR_DURATION;

			// Construct the set command
			let setCommand = {
				Properties1: {
					'Color Component Count': 2,
				},
				vg1: [
					{
						'Color Component ID': 0,
						Value: WarmWhite,
					},
					{
						'Color Component ID': 1,
						Value: ColdWhite,
					},
				],
			}

			// Add duration if Switch Color is version 2 and up
			if (CC_ColorSwitch.version > 1) setCommand.duration = duration;

			// Send the set command
			CC_ColorSwitch.SWITCH_COLOR_SET(setCommand)
				.catch(error => {
					return Promise.resolve(error, false);
				})
				.then(result => {
					if (result !== 'TRANSMIT_COMPLETE_OK') return Promise.resolve(result, false);

					this.setCapabilityValue('light_temperature', temperature);

					return Promise.resolve(true);
				});
		}

		else return Promise.resolve('something_went_wrong', false);
	}
}

// Map values from one range to the other range
function map(inputStart, inputEnd, outputStart, outputEnd, input) {
	return outputStart + ((outputEnd - outputStart) / (inputEnd - inputStart)) * (input - inputStart);
}

module.exports = ZwaveXYLightDevice;
